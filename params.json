{"name":"FluentJdbc","tagline":"Java library for efficient native SQL querying (through JDBC)","body":"####About FluentJdbc####\r\nFluentJdbc is a java library for operating with SQL queries conveniently. Every SQL operation is a single,\r\nreadable api call without any of the JDBC clutter. It supports functionality that most similar\r\njdbc wrappers prevent or abstract away, more details below.\r\n\r\nFluentJdbc's key features:\r\n* functional, fluent API\r\n* execution of select/insert/update/delete/alter/... statements as one-liners\r\n* parameter mapping (named, positional, supports java.time, plugins for custom types)\r\n* accessing generated keys of insert/update queries\r\n* transaction handling\r\n* big data (scalable, streaming style of batch and select)\r\n* automatic result to pojo mapping\r\n* database inspection\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.codejargon</groupId>\r\n    <artifactId>fluentjdbc</artifactId>\r\n    <version>1.0.2</version>\r\n</dependency>\r\n```\r\nNote: requires java 8\r\n\r\nFull documentation on [wiki](https://github.com/zsoltherpai/fluent-jdbc/wiki/Motivation)\r\n\r\nLatest [javadoc](https://github.com/zsoltherpai/fluent-jdbc/wiki/Javadoc)\r\n\r\n#####News#####\r\n* 1.0.2 released - batching API improvements (accepting Stream and Iterable)\r\n\r\n#####Code examples of common use cases#####\r\n######Setting up FluentJdbc######\r\n```java\r\nDataSource dataSource = ...\r\nFluentJdbc fluentJdbc = new FluentJdbcBuilder()\r\n\t.connectionProvider(dataSource)\r\n\t.build();\r\nQuery query = fluentJdbc.query();\r\n// ... use the Query interface for queries (thread-safe, reentrant)\r\n```\r\nNote: using a DataSource is the most common, there are other alternatives documented on the [wiki](https://github.com/zsoltherpai/fluent-jdbc/wiki/Motivation)\r\n######Update or insert queries######\r\n```java\r\nquery\r\n\t.update(\"UPDATE CUSTOMER SET NAME = ?, ADDRESS = ?\")\r\n\t.params(\"John Doe\", \"Dallas\")\r\n\t.run();\r\n```\r\n######Query for a list of results######\r\n```java\r\nList<Customer> customers = query\r\n\t.select(\"SELECT * FROM CUSTOMER WHERE NAME = ?\")\r\n\t.params(\"John Doe\")\r\n\t.listResult(customerMapper);\r\n```\r\n######Mapping of results######\r\nMapper<Customer> can be implemented manually\r\n```java\r\nresultSet -> new Customer(resultSet.getString(\"NAME\"), resultSet.getString(\"ADDRESS\"));\r\n```\r\nor mapping can be performed automatically to a java object\r\n```java\r\nObjectMappers objectMappers = ObjectMappers.builder().build(); //typically one instance per app\r\n...\r\nMapper<Customer> customerMapper = objectMappers.forClass(Customer.class);\r\n```\r\n######Query for single result######\r\n```java\r\nLong count = query\r\n\t.select(\"SELECT COUNT(*) FROM CUSTOMER WHERE NAME = ?\")\r\n\t.params(\"John Doe\")\r\n\t.singleResult(Mappers.singleLong);\r\n```\r\n######Query for first result######\r\n```java\r\nOptional<Customer> customer = query\r\n\t.select(\"SELECT FROM CUSTOMER WHERE NAME = ?\")\r\n\t.params(\"John Doe\")\r\n\t.firstResult(customerMapper);\r\n```\r\n\r\n######Batch insert or update######\r\n```java\r\nIterator<List<Object>> params = ...; // or Stream/Iterable\r\nquery\r\n\t.batch(\"INSERT INTO CUSTOMER(NAME, ADDRESS) VALUES(?, ?)\")\r\n\t.params(params)\r\n\t.run();\r\n```\r\n######Named parameters######\r\n```java\r\nMap<String, Object> namedParams = new HashMap<>();\r\nnamedParams.put(\"name\", \"John Doe\");\r\nnamedParams.put(\"address\", \"Dallas\");\r\n\r\nquery\r\n\t.batch(\"UPDATE CUSTOMER SET NAME = :name, ADDRESS = :address\")\r\n\t.namedParams(namedParams)\r\n\t.run();\r\n```\r\n\r\n######java.time support for query parameters######\r\n```java\r\nquery\r\n\t.update(\"UPDATE CUSTOMER SET DEADLINE = ?, UPDATED = ?\")\r\n\t.params(LocalDate.of(2015, Month.MARCH, 5), Instant.now())\r\n\t.run();\r\n```\r\n######Iterating a large resultset######\r\n```java\r\nquery\r\n\t.select(\"SELECT * FROM CUSTOMER\")\r\n\t.iterateResult(customerMapper, (customer) -> {\r\n\t\tif(customer.isExpired()) {\r\n\t\t\t...\r\n\t\t}\r\n\t});\r\n```\r\n######Query for a list of limited results######\r\n```java\r\nList<Customer> customers = query\r\n\t.select(\"SELECT * FROM CUSTOMER WHERE NAME = ?\")\r\n\t.params(\"John Doe\")\r\n\t.maxRows(345L)\r\n\t.listResult(customerMapper);\r\n```\r\n######Fetching generated key of an insert or updates######\r\n```java\r\nUpdateResultGenKeys<Long> result = query\r\n\t.update(\"INSERT INTO CUSTOMER(NAME) VALUES(:name)\")\r\n\t.namedParams(namedParams)\r\n    .runFetchGenKeys(Mappers.singleLong());\r\nLong id = result.generatedKeys().get(0);\r\n```\r\n######Querying using a specific connection object######\r\n```java\r\nConnection connection = ...\r\nQuery query = fluentJdbc.queryOn(connection);\r\n// do some querying...\r\n```\r\n######Transactions######\r\n```java\r\nquery.transaction().in(\r\n\t() -> {\r\n\t\tquery\r\n        \t.update(\"UPDATE CUSTOMER SET NAME = ?, ADDRESS = ?\")\r\n        \t.params(\"John Doe\", \"Dallas\")\r\n        \t.run();\r\n\t\tsomeOtherBusinessOperationAlsoNeedingTransactions();\r\n\t}\r\n)\r\n```\r\nAll queries executed in the block will be part of the transaction - in the same thread, based on the same FluentJdbc/ConnectionProvider.\r\nExceptions cause rollback. It is possible to use multiple transactions/datasources simultaneously.\r\n\r\nRefer to the [full documentation](https://github.com/zsoltherpai/fluent-jdbc/wiki/Motivation) for more details and code examples.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}